#-------------------------------------------------------------------------------
# pylint: disable=line-too-long
# pylint: disable=invalid-name
# pylint: disable=too-many-instance-attributes
# pylint: disable=broad-except
# pylint: disable=too-many-arguments
# pylint: disable=too-many-positional-arguments
# pylint: disable=too-many-branches
# pylint: disable=too-many-statements
# pylint: disable=too-many-locals
# pylint: disable=too-many-lines
"""-------------------------------------------------------------------------------
# HAOS Kiosk Display — Mouse & Touch Input Engine
# File: MouseTouchInputs
# Version: 1.2.0
# Copyright Jeff Kosowsky
# Date: December 2025
#
#### DESCRIPTION:
   Full-featured X11 parser and command launcher for multi-button press and
   multi-finger touch gestures.

   Commands can then be assigned to a broad range of mouse and touch gestures,
   including multi-button/multi-finger: Click/Tap, Drag, Swipe, Long
   click/tap, and Click/Tap in the top-right corner.  Multi click/tap
   gestures are allowed for click/tap events

#### USAGE:
   mouse_touch_inputs.py [-d|--debug <DEBUG_LEVEL>] [-f|--file <COMMAND_GESTURE_FILE>]

## Debug Levels:
   0: Only errors and action messages
   1: + Printout command gesture dictionary + log gestures and action commands for assigned commands
   2: + Input actions (press/release/motion) + xinput device headers + gesture command loading + execution output
   3: + State info (click_dict, finger state) + double-press timeout + screen dimension + missing gesture commands
   4: + Contact group data+ GESTURE_NAME_TO_TYPE, DEVICE_TYPE_PATTERN and GESTURE_NAMES_PATTERN  lists
   5: + Key lines from xinput event stanza
   6: + RAW data for CLICK_EVENTS
   7: + RAW data for PARSED_EVENTS
   8: + RAW data for all xinput X11 events
  -2: Log xinput device headers only
  -6: + RAW data for CLICK_EVENTS
  -7: + RAW data for PARSED_EVENTS
  -8 + RAW data for all xinput X11 events

#### Key Data Structures

### EventRecord: (Tuple alias)

An event is the fundamental unit of a touch gesture with a 3-Tuple consisting
of: (event_time, event_position, contact_state), where event_position = (x,y)
and contact_state is one of PRESS, RELEASE or Motion.  Every press or release of
every individual key or finger is recorded as an event.  Motion is optionally
recorded between press and release events

### ContactGroup (class)
#   Associated structures:
       ContactState (enum): Press, Motion, Release

A Contact Group is the fundamental unit of a click gesture. It captures all the
events associated with a contact (click or touch) generated by an input device
(whether MOUSE or TOUCH) from the initial button click or finger touch until the
final button or finger release. Plus, optionally include motion data between
initia press and final release event for the group if PARSED_EVENTS includes
MOTION_EVENTS

Each group is a dictionary of events keyed by input device (e.g., mouse,
touchscreen), whose values are time ordered sequences of events (indexed by
button or finger) for each input device (MOUSE or TOUCH). At any time, there is
at most one group associated with each input device. A group is complete after
all contacts (fingers or buttons) have been released.

Each group has an associated peak number of members defined as the list of
contact elements (buttons or fingers) present at the first point of maximum
simultaneous contacts). Note that the number and identity of the set of buttons
or fingers contacting generally varies from the start to the end of an event.

# GestureSequence (class)

A gesture is a sequence of contact groups defining a full gesture. It contains
an ordered list of all N groups (where N>=1) associated with the gesture from
the first to the last contact event (where each group represents a completed
click or touch contacts consisting of one or more buttons or fingers). Each
group in the gesture sequence must have the same number of peak contacts
(buttons or fingers) and for a mouse where buttons are named, the same
individual buttons. At any time, there is at most one gesture sequence
associated with each input device.

Note that a gesture sequence is considered ready for closeout (i.e., finalized)
when either:
    - Time since prior press (start of prior group) exceeds the double-press timeout
    - The last (completed) group is by definition a non-multiclick gesture
      (e.g., Drag, Swipe, or Long)

Said another way, Drag, Swipe and Long gestures consist of a single group while
N-Click/Tap or N-Corner_Top consists of exactly N groups.

### DeviceSpec (class)
#   Associated structures:
       DeviceType (enum): MOUSE, TOUCH, DEFAULT, UNKNOWN, ANY
       GestureType (enum): CLICKTAP, LONG, SWIPE, DRAG, CORNER_TOP,
                           SWIPE_[LEFT|RIGHT|UP|DOWN], DRAG_[LEFT|RIGHT|UP|DOWN],
                           UNKNOWN, ANY,
           NOTE: A DRAG differs from a SWIPE in that it is slower (less than
           swipe velocity threshold)

A DeviceSpec assigns attributes to each DeviceType (currently, MOUSE and TOUCH),
including: device name (e.g., Mouse, Touch), contact type (Button, Finger),
gesture dictionary of supported GestureTypes, double click timeout, long click
duration, movement threshold, swipe velocity threshold, corner dimension, and a
list of supported gestures to be classified as multi-click

### GestureCommand (class)
#   Associated structures:
       RangeNumber (class): Integer with optional range semantics where
         - 'N+' means N or greater (and 1+ is thus a wildcard for positive integers)
         - 'N-' means N or less
         - 'N' (no sign) means exactly N

       CommandsType (TypeAlias): A single shell command represented either as:
         - Single command string (e.g., "ls -a -l")
         - List of one or more commands in either of the 2 forms
           - String form  (e.g., "ls -a -l")
           - List of argv-style component string (e.g., ["ls", "-a", "-l"])

       CommandsDict (TypeDict)  Commands stored as a dictionary with keys:
           - cmds: CommandType representing command(s) to be executed
           - msg: Message string to printout (optional)
           - timeout: Overrides default CMD_TIMEOUT (per command) (optional)
         NOTE: This is the primary form for storing commands

       CommandsUnion (TypeAlias): Union of two forms of commands:
           - CommandsType
           - CommandsDict
         NOTE: This is the form that can be used for user-defined commands

The GestureCommand class is used to define and parse gesture strings and map
them to the user-defined command(s) that are to be triggered and executed by the
gesture.

Each gesture command instance is characterized by:
  - Device type (e.g, mouse or touch)
  - Number of contacts (N, N+, N-)
  - Contact members (list of buttons/fingers) and/or Contact number (number of contacts)
  - Number of separate clicks/touches in the gesture (N, N+, N-)
  - Gesture type: GestureType (e.g., CLICKTAP, LONG, DRAG, SWIPE, CORNER_TOP, etc.)
  - Commands: CommandsDict ("cmds" plus optional "msg" and "timeout")

Corresponding to the GestureCommand class, users can enter human readable lists
of key-value pairs consisting of Gesture String Keysand Action command Values
where:

- Gesture String keys are of form:
    <CONTACTS>_<DEVICE>_<CLICKS>_<GESTURE>
    where:
       <CONTACTS> = The maximal contact set during the gesture. Either:
         - Number (N, N+, N-) representing (maximum) number of contacts (buttons or fingers)
           where N+ and N- are respectively greater than and less than or equal to N
         - List of button numbers and/or corresponding button names if a mouse
           (e.g., [Left, Right] or [1, 3] or [Left, 3])

       <DEVICE> =  Either:
           - Device Type (e.g., MOUSE, TOUCH) or the wildcard "ANY"
           - Device Name (e.g., Button, Finger)

       <CLICKS> = Number (M, M+, M-) of clicks/taps in the gesture where M+ and M-
                  are respectively greater than or less than or equal to M
                  (e.g., 1 for single-click, 2 for double-click, 2+ for 2 or more clicks)

      <GESTURE> = Either:
           - GestureType (e.g., CLICKTAP, DRAG, SWIPE, LONG, CORNER_TOP) or the wildcard "ANY"
           - Gesture Name (e.g., Click, Tap, Drag, Swipte, Long Click, Long Tap)
               Note that gesture names are device specific (e.g. Click for Mouse, Tap for Touch)

        where:
          - ANY is a wildcard match for any gesture
          - DRAG and SWIPE differ in velocity -- i.e., SWIPE is *faster*
          - The gestures DRAG and SWIPE can also have the optional suffixes: _LEFT, _RIGHT, _UP, or _DOWN
          - Conversely, DRAG and SWIPE serve as wildcard matches relative to
            their directional counterparts
          - LONG can take the optional suffix _CLICK or _TAP
          - CORNER_TOP activates when click or tap is in the extreme top-right corner of the scree
          - DRAG, SWIPE, and LONG gestures (and their variants) are by definition only single-click
          - Matching is case insensitive

    NOTE: Keys are matched in order, so that you should always go from
    particular to more general when using wildcards

    NOTE: Validity checks are imposed including:
            - Cannot have more than 1 click for single click gestures
            - Click and Tap gesture words correspond only to Mouse and Touch
              devices respectively

 Example gesture strings include:
    [Left, Right]_MOUSE_3_CLICKTAP
    [1,2,3]_MOUSE_1+_CORNER_TOP
    2_TOUCH_1_DRAG_LEFT
    2_Button_1_Long Click
    3_Finger_2_Tap
    2+_Finger_1_Swipe_down
    1_ANY_2-_CLICKTAP
    1+_ANY_1+_ANY

 Invalid examples include:
    1_Mouse_3-Tap  (Tap is for Touch)
    1-Touch_2-Long (Long gestures can only be single contact)

- Action Command values (CommandsUnion-like type) can be expressed in one of the following 3 forms:
    1. Single command string - e.g., "ls -a -l"
       Note that an empty string acts as a No-Op -- i.e., it will be ignored and can be
       used with wildcard gestures to block actions of lower priority.

    2. List of one or more commands each of which is can be one of the following forms:
        - String form - e.g., ["echo hello"]
        - List of argv-style component string - e.g., ["ls", "-a", "-l"]
       Example: ["echo hello", ["ls", "-a", "-l"]]

    3. Dictionary with required key "cmds" and optional keys: "msg", "timeout"
        where the value of "cmds" is of form 1 or 2
        e.g., {"cmds": "ls -al", "msg": "list all files", "timeout": 1}
        e.g., {"cmds": ["echo hello", ["ls" "-al"]], "msg": "echo hello and list all files", "timeout": 5}

Users can enter such lists either as:

- A DEFAULT_CMDS_DICT dictionary global variable in this file with Gesture
  String Keys and Acttion Command Values

- One or more external files (contained in the variable CMDS_FILE_LIST or
  entered via the command line parameter --file|-f)

  Key-pairs can be entered in these files in any of the following formats:
    1. JSON dictionary of <gesture string>: <CommandsUnion> pairs, separated by commas
    2. Same as #1 but without enclosing starting and ending braces
    3. JSON dictionary with at least one key called "gestures" whose value is a list of
       strings of form: "<gesture string>: <CommandsUnion>"
       Used in HA add-ons to load /data/options.json)

All these sources, are parsed, validated, and loaded at runtime into a
GESTURE_CMDS_LIST which is a list of GestureCommand instances. Files are loaded
in the following order:
   - Command line file (if any)
   - CMDS_FILE_LIST (in order of listing)
   - DEFAULT_CMDS_DICT

When a gesture sequence is generated, the GESTURE_CMDS_LIST is used to find the
first matching Gesture String Key entry and associated Action Command. As such,
entries loaded earlier *override* later entries in matching hierrarchy.


### XInputParser (class)
#   Associated structures
       XEvent (enum):  X11 event mapping number to name
       MouseButton (enum): Maps button number to name
       XInputEvent (class): Used to store key attributes for each event

       MOUSE_EVENTS (set): X11 events corresponding to mouse press, release, motion
       TOUCH_EVENTS (set): X11 events corresponding to touch begin, end, motion
       CLICK_EVENTS (set): X11 events corresponding to mouse press/release, touch begin/end
       MOTION_EVENTS (set): X11 events corresponding to mouse motion and touch update
       PARSED_EVENTS (set): CLICK_EVENTS +/- MOTION_EVENTS

This class is used in the main event parser loop where events are read in from
'xinput' with each event stanza then  parsed sequentially and stored in an
XInputEvent instance. For mice: button press/release, and optionally motion
events are parsed. For touch devices: touch begin/end, and optionally update
events are parsed.

After each press-type event, the new event is either added to an existing group
for the input device if the group is not yet complete (i.e., still
buttons/fingers pressed) or a new group is started for the device.

If PARSED_EVENTS includes MOTION_EVENTS, then each motion event between press
and release is added to the current incomplete group for the device. I.e.,
motion is only (optionally) recorded between individual button or finger presses
and releases.

After each release-type event, the event is added to its corresponding already
created group. If the group then becomes complete (all contacts released), then
the new group is added to an existing gesture sequence (if one already exists
for the device with the same peak contacts) or a new one is created.

An attempt is then made to closeout the gesture sequence and execute any
associated gesture command actions.

A gesture sequence can be closed-out if any of the following conditions are met:

  - The last group is a (completed) Drag, Swipe or Long click/tap based,
    respectively, on the distance moved or time elapsed since the group started
    (first button press or finger touch).

    If there are more than one group in the gesture sequence (say N), then the
    preceding N-1 groups are retroactively and immediately closed-out as an
    (N-1)-Click or Tap, and the final Nth group is then also immediately closed
    out as Drag, Swipe or Long.

  - The time elapsed since the start of the prior group (previous press) exceeds
    the double click timeout time for the device. If that time has not yet been
    exceeded, a timer is set and the sequence is queued for expiry. When the
    timeout expires, the sequence will be closed out if no other group added
    (i.e., no new press)

If the sequence is closeable, the associated gesture string is used to look for
a matching gesture string in the Gesture Commands List.  The lookup returns the
first gesture command on the list that matches (whether exactly or as a wildcard
superset). If a match exists, the commands are then processed asynchronously.

Note: 'xinput' provides both 'Raw' and 'Cooked' (non-Raw) events for TouchBegin
and TouchEnd events but only 'Raw' events for ButtonPress and ButtonRelease
events.  Unfortunately, only 'Cooked' events have a root line giving absolute
position coordinates whie 'Raw' events show relative distances (dx, dy) in the
valuator lines..

Now motion and RawMotion events give root and relative positions for Mouse
buttons, respectively.  So, theoretically, by tracking the position in Motion
events, one can determine the position at the time of Button press (assuming
there has been prior motion).  However, Motion events stop during button press
so that they can't give the position at time of release. One could attempt to
use the relative motion coordinates to track relative mouse motion between press
and release events and use that to calculate the position at release. However,
such tracking and calculations are cumbersome and potentially fragile. To avoid
these issues, the program instead uses the Xlib query_pointer() function to
return the position of the mouse any time a raw mouse event is recorded.

-----
In summary, you can think of the following sequence:

XInputParser -> XInputEvent -> ContactGroup -> GestureSequence
-> GestureType classification -> GestureCommand execution

"""

#-------------------------------------------------------------------------------
# MYTODOS: <None>
#-------------------------------------------------------------------------------
#### Imports
from __future__ import annotations  # ensures forward references are strings
from dataclasses import dataclass, field
from enum import Enum, IntEnum, auto
from math import atan2, degrees, inf
import argparse
import json
import os
import re
import subprocess
import time
import threading
import traceback
import uuid
from collections.abc import Hashable
from typing import Any, cast, ClassVar, Iterator, NotRequired, Protocol, Self, Type, TypeAlias, TypedDict, TypeVar
from Xlib import display                  #type: ignore[import-untyped] #pylint: disable=import-error
from Xlib.xobject.drawable import Window  #type: ignore[import-untyped] #pylint: disable=import-error
#-------------------------------------------------------------------------------
__version__ = "1.2.0"
__author__ = "Jeff Kosowsky"
__copyright__ = "Copyright 2025 Jeff Kosowsky"
#-------------------------------------------------------------------------------
#### User Configuration

# Restart delay
XINPUT_RESTART_DELAY: int     = 5    # Seconds before restarting xinput after crash
CMD_TIMEOUT: int | None       = 30   # Seconds before spawned action command timesout or None if no timeout
GESTURE_CMDS_FILES: list[str] = ["/data/options.json", "gesture_commands.json"]

def initialize() -> None:
    """Initialize variables"""

    #--- Initialize command dictionary ---
    TOGGLE_ONBOARD_KEYBOARD: CommandsDict = {  # Toggle Onboard keyboard visibility
        'cmds': [[
            "dbus-send",
            "--type=method_call",
            "--dest=org.onboard.Onboard",
            "/org/onboard/Onboard/Keyboard",
            "org.onboard.Onboard.Keyboard.ToggleVisible",
        ]],
        'msg': "Toggling Onboard keyboard...",
    }

#    DEFAULT_COMMANDS_DICT["[Left]-MOUSE_3-CLICK"] = TOGGLE_ONBOARD_KEYBOARD
#    DEFAULT_COMMANDS_DICT["3-TOUCH_1-TAP"]        = TOGGLE_ONBOARD_KEYBOARD
#    DEFAULT_COMMANDS_DICT["1-MOUSE_1-CORNER_TOP"] = TOGGLE_ONBOARD_KEYBOARD
#    DEFAULT_COMMANDS_DICT["1-TOUCH_1-CORNER_TOP"] = TOGGLE_ONBOARD_KEYBOARD

    ## Load COMMANDS_DICT into GESTURE_CMDS_FILES
    GestureCommand.initialize_gesture_command_list(GESTURE_CMDS_FILES)

#-------------------------------------------------------------------------------
#### Input arguments

def parse_args() -> argparse.Namespace:
    """Parse command line arguments: -d|--debug, -f|--file"""
    parser = argparse.ArgumentParser(description="Mouse Touch Inputs")

    parser.add_argument("-d", "--debug", type=int, default=0,
                        help="""
Debug levels:
  0: No logging
  1: Log only final results
  2: + Input actions (press/release) + xinput device headers
  3: + State info (click_dict, finger state)
  4: + Key lines from xinput event stanza
  5: + RAW data for CLICK_EVENTS
  6: + RAW data for PARSED_EVENTS
  7: + RAW data for all xinput X11 events
  -2: Log xinput device headers only
  -5: + RAW data for CLICK_EVENTS
  -6: + RAW data for PARSED_EVENTS
  -7: + RAW data for all xinput X11 events
""")
    parser.add_argument("-f", "--file", type=str,
           help="Path to gesture commands JSON file")
    return parser.parse_args()

input_args: argparse.Namespace  = parse_args()

LOG_LEVEL = input_args.debug

if input_args.file is not None:
    GESTURE_CMDS_FILES.insert(0, input_args.file)

#-------------------------------------------------------------------------------
#### Globals
GESTURE_SEP = "_"
_registry_lock: threading.RLock = threading.RLock()

#-------------------------------------------------------------------------------
#### Utility Functions
def debug(level: int, msg: str) -> None:
    """Conditional debug print."""
    if LOG_LEVEL >= level:
        print(msg)

def truncate_time(t: float | None) -> str:
    """Format time in seconds, with 1000s rollover."""
    if t is not None:
        t = t % 1000  # Rollover after 1000 sec
        return f"{t:.3f}"
    return "0"

def sec_to_ms (t: float | None, prec: int = 0) -> str:
    """Convert seconds to milliseconds with 'prec' digits of precision"""
    if t is not None:
        return f"{t*1000:.{prec}f}"
    return "0"


#-------------------------------------------------------------------------------
#### Mixins
class EnumBase(Protocol):  # pylint: disable=too-few-public-methods
    """Needed to type hint attributes like .name and .value in EnumNameMixin"""
    name: str
    value: Any

class EnumNameMixin(Enum):
    """Mixin for Enum classes that provides safe string lookup methods."""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        pass

    @classmethod
    def safe_name(cls, value: Any) -> str:
        """
        Safely return the name of an enum member for a numeric value.

        If the value is already a member of the enum, returns its `.name`.
        If the value can be converted to a member, returns the corresponding `.name`.
        Otherwise, returns str(value)

        Args:
            value (int | Any): Numeric value to look up in the enum.

        Returns:
            str | Any: Name of the enum member if found, otherwise the original value

        Example:
            >>> class ColorType(Enum, EnumNameMixin):
            ...     RED = "red"
            ...     GREEN = "green"
            ...
            >>> ColorType.safe_name(ColorType.RED)
            'RED'
            >>> ColorType.safe_name("green")
            'GREEN'
            >>> ColorType.safe_name("unknown")
            'unknown'
        """

        if isinstance(value, cls):  # If value is already an Enum member of this class
            return value.name

        try: # If value is an integer (or something that can construct the enum)
            return cls(value).name
        except (ValueError, TypeError):
            return str(value)  # Not convertible → just return it as-is

    def __str__(self) -> str:
        """
        Return a readable string representation of the enum member.

        Overrides the default string conversion so that printing an enum
        directly shows its .name instead of the full Enum type.

        Args:
            self: The enum instance.

        Returns:
            str: Name of the enum member.

        Example:
            >>> class ColorType(Enum, EnumNameMixin):
            ...     RED = "red"
            ...     GREEN = "green"
            ...
            >>> str(ColorType.RED)
            'RED'
            >>> str(ColorType.GREEN)
            'GREEN'
        """
        return self.name


    @property
    def value_str(self) -> str:
        """
        Return a stable, readable string representation of the enum member’s value.

        This is useful when the enum's `.value` is not a simple string, or you want
        a consistent programmatic name separate from `.name`.

        Returns:
            str: A string representing the enum member's value.

        Example:
            >>> class ColorType(Enum, EnumNameMixin):
            ...     RED = "red"
            ...     GREEN = "green"
            ...
            >>> ColorType.RED.value_str
            'red'
            >>> ColorType.GREEN.value_str
            'green'
        """
        return str(self.value)

class RegistryMixin:
    """
    Mixin that provides a per-subclass registry of instances.

    Each subclass maintains its own `_registry`, keyed by a hashable ID.
    This allows storing and retrieving instances without collisions
    between different subclasses. Any hashable object can be used as the ID.
    """

    # Class-level mapping of subclass -> registry dict
    _registries: dict[Type[Self], dict[Hashable, Self]] = {}

    id: Hashable  #Every instance must have `id`

    @classmethod
    def _registry(cls) -> dict[Hashable, Self]:
        """Get the registry for this subclass, creating it if necessary."""
        if cls not in cls._registries:
            cls._registries[cls] = {}
        return cls._registries[cls]

    @classmethod
    def register(cls, obj: Self) -> None:
        """Register an instance using its hashable ID"""
        cls._registry()[obj.id] = obj

    @classmethod
    def get(cls, obj_id: Hashable) -> Self | None:
        """Retrieve an instance from the subclass registry using its ID or None if not found."""
        return cls._registry().get(obj_id)

    @classmethod
    def all_instances(cls) -> list[Self]:
        """Return a list of all currently registered instances for this subclass."""
        return list(cls._registry().values())

    @classmethod
    def unregister(cls, obj_id: Hashable) -> None:
        """Remove an instance from the subclass registry by ID."""
        cls._registry().pop(obj_id, None)

    def is_registered(self) -> bool:
        """Check if this instance is registered in its subclass registry."""
        return self.id in type(self)._registry()

#-------------------------------------------------------------------------------
#### Enums

### X11 Mouse and Event Definitions
class MouseButton(EnumNameMixin, IntEnum):
    """X11 Button assignments (this is the value of 'detail' for Mouse ButtonPress and ButtonRelease)"""
    Left = 1
    Middle = 2
    Right = 3
    ScrollUp = 4
    ScrollDown = 5
    ScrollLeft = 6
    ScrollRight = 7
    Back = 8
    Forward = 9

class XEvent(EnumNameMixin, IntEnum):
    """X11 Events (Note: in general only the non-raw versions expose root coordinates for Mouse and Touch contacts and movements)"""
    DeviceChanged    = 1   # Device enabled/disabled
    KeyPress         = 2
    KeyRelease       = 3
    ButtonPress      = 4   # Not broadcast to root, use raw version instead
    ButtonRelease    = 5   # Not broadcast to root, use raw version instead
    Motion           = 6   # Root coordinates
    Enter            = 7   # Pointer enters window
    Leave            = 8   # Pointer leaves window
    FocusIn          = 9
    FocusOut         = 10
    HierarchyChanged = 11
    PropertyEvent    = 12
    RawKeyPress      = 13
    RawKeyRelease    = 14
    RawButtonPress   = 15  # Use this since no unraw version broadcast to root (but lacks root coordinates)
    RawButtonRelease = 16  # Use this since no unraw version broadcast to root (but lacks root coordinates)
    RawMotion        = 17
    TouchBegin       = 18  # Root coordinates
    TouchUpdate      = 19  # Root coordinates
    TouchEnd         = 20  # Root coordinates
    TouchOwnership   = 21
    RawTouchBegin    = 22
    RawTouchUpdate   = 23
    RawTouchEnd      = 24
    UNKNOWN          = 1000

    @classmethod
    def get_event(cls, number: int) -> "XEvent":
        """Safely return the matching XEvent or UNKNOWN if value is not valid."""
        try:
            return cls(number)
        except ValueError:
            print(f"WARNING: Unknown XEvent: {number}")
            return cls.UNKNOWN

MOUSE_EVENTS: set[XEvent]   = {XEvent.ButtonPress, XEvent.ButtonRelease, XEvent.Motion, XEvent.RawButtonPress, XEvent.RawButtonRelease, XEvent.RawMotion}
TOUCH_EVENTS: set[XEvent]   = {XEvent.TouchBegin, XEvent.TouchEnd, XEvent.TouchUpdate, XEvent.RawTouchBegin, XEvent.RawTouchEnd, XEvent.RawTouchUpdate}

PRESS_EVENTS: set[XEvent]   = {XEvent.RawButtonPress, XEvent.TouchBegin} # Use 'Raw" for ButtonPress and ButtonRelease since the 'cooked' ones are not broadcast
RELEASE_EVENTS: set[XEvent] = {XEvent.RawButtonRelease, XEvent.TouchEnd}
MOTION_EVENTS: set[XEvent]  = {XEvent.RawMotion, XEvent.TouchUpdate}  # Use 'Raw' for mouse Motion since no motion updates during button presses

MOUSE_MOTION_EVENTS: set[XEvent] = MOUSE_EVENTS & MOTION_EVENTS

CLICK_EVENTS: set[XEvent]   = PRESS_EVENTS | RELEASE_EVENTS
PARSED_EVENTS: set[XEvent]  = CLICK_EVENTS # Not including motion updates now (same as CLICK)
#PARSED_EVENTS: set[XEvent]  = CLICK_EVENTS | MOTION_EVENTS # Include motion updates

class ContactState(Enum):
    """State of Button or Touch event"""
    PRESS = "Press"
    MOTION = "Motion"
    RELEASE = "Release"

#-------------------------------------------------------------------------------
### Gesture types

class GestureType(EnumNameMixin, Enum):
    """Class of Mouse/Touch gesture types"""
    UNKNOWN = auto()
    CLICKTAP = auto()
    LONG = auto()
    SWIPE = auto()
    DRAG = auto()

    CORNER_TOP = auto()

    SWIPE_LEFT = auto()
    SWIPE_RIGHT = auto()
    SWIPE_UP = auto()
    SWIPE_DOWN = auto()

    DRAG_LEFT = auto()
    DRAG_RIGHT = auto()
    DRAG_UP = auto()
    DRAG_DOWN = auto()

    ANY = "ANY"  # Wildcard

    @property
    def base_type(self) -> GestureType:
        """Return SWIPE or DRAG from SWIPE_LEFT, etc."""
        try:
            return GestureType[self.name.split('_', 1)[0]]
        except (ValueError, IndexError, KeyError):
            return self  # for ANY, UNKNOWN, CLICKTAP, etc.

GestureData: TypeAlias = tuple[GestureType, float, float, float]  # (GestureType, distance, angle, velocity)

#-------------------------------------------------------------------------------
### Device Spec and Types

@dataclass(slots=True,frozen=True)
class DeviceSpec:
    """
    Immutable device configuration for gesture classification and naming.
    All attributes except for gesture mapping are inherited from DEFAULT DeviceSpec
    when using 'get' method to access them
    Gesture mappings not inherited allowing only specified gestures to be implemented
    """
    # Inherited attributes (use 'get' method)
    device_name: str  # Friendly name of the Device
    contact_type: str  # Friendly name for the contact type associated with the device (e.g., "Button" or "Touch")

    double_click_timeout: float | None = None  # Maximum interval between successive clicks/taps to be part of same gesture (seconds)
    long_click_duration: float | None = None  # Minimum duration for LONG gesture (seconds)
    movement_threshold: float | None = None # Minimum distance to distinguis swipe or drag (pixels)
    swipe_velocity_threshold: float | None = None  # Minimum velocity for swipe (pixels/sec)
    drag_velocity_threshold: float | None = None  # Maximum velocity for drag (pixels/sec)
    corner_dim: int | None = None# Dimension of corner block (used for determining, for example, CORNER_TOP).
    multi_click_gestures: set[GestureType] | None = None  # Gesture types that can be multi-click/tap

    # Non-inherited
    gestures: dict[GestureType, str] = field(default_factory=dict)  # Dictionary mapping GestureType -> device-specific friendly name for gesture (needs factory default since frozen)

    # Fallback used for inherited attributes when accessing via 'get' method
    DEFAULT: DeviceSpec | None = None

    def get_attr(self, attr: str) -> Any:
        """Generic getter with fallback to DEFAULT. Gestures do not inherit!"""
        if attr == "gestures":  # Not inherited
            return self.gestures

        value = getattr(self, attr)
        if value is not None:
            return value
        if self.DEFAULT is not None:  # Inherit
            return getattr(self.DEFAULT, attr)
        return None

    def supports (self, gesture: GestureType) -> bool:
        """
        True if this device defines a mapping for this gesture.
        Gestures do NOT inherit from DEFAULT.
        """
        return gesture in self.gestures


    SCREEN_DIM: ClassVar[tuple[int, int ] | None] = None # Don't use ClassVar as it makes them "unsubscriptable" (e.g., can do SCREEN_DIM[0])
    @classmethod
    def init_screen_dim(cls) -> None:
        """Initializes SCREEN_DIM class variable"""
        d = None
        try:
            d = display.Display()
            geometry = d.screen().root.get_geometry()
            cls.SCREEN_DIM =  geometry.width, geometry.height
            debug(3, f"Screen dimension: {cls.SCREEN_DIM}")
        except Exception:
            debug(3, "WARNING: Could not determine screen dimension")
        finally:
            if d is not None:
                d.close()

    def classify_click(self, duration: float, start_pos: tuple[int, int], end_pos: tuple[int, int]) -> GestureData:
        """
        Classify a click/gesture based on device thresholds.
        Parameters:
          - duration: length of click
          - start_pos: (x, y) start coordinates in pixels
          - end_pos: (x, y) end coordinates in pixels

        Returns:
          - gesture: GestureType if determined, None if waiting for multi-click
          - distance: Euclidean distance in pixels
          - angle: Angle in degrees (0° = right, 90° = up)
          - velocity: pixels/sec
        """

        dx = end_pos[0] - start_pos[0]
        dy = end_pos[1] - start_pos[1]

        distance = (dx**2 + dy**2)**0.5
        velocity = distance / duration if duration > 0 else 0.0
        angle = degrees(atan2(dy, dx)) if dy and dx else 0

        cls = type(self)

        # --- CLICKTAP gesture ---
        gesture = GestureType.CLICKTAP  # This is the fallback

        # --- Movement >= threshold: DRAG or SWIPE depends on velocity ---
        if ((self.supports(GestureType.SWIPE) or self.supports(GestureType.DRAG)) and  # DRAG or SWIPE
            (movement_thresh := self.get_attr("movement_threshold")) is not None and distance > movement_thresh):

            if velocity >= self.get_attr("swipe_velocity_threshold") or not self.supports(GestureType.DRAG):
                motion = "SWIPE"
            else:
                motion = "DRAG"

            if abs(dx) > abs(dy):
                direction = "RIGHT" if dx > 0 else "LEFT"
            else:
                direction = "DOWN" if dy > 0 else "UP"

            gesture = getattr(GestureType, f"{motion}_{direction}")  # Directed gesture
            if not self.supports(gesture):
                gesture = getattr(GestureType, motion)  # Fallback to non-Directed gesture

        # --- LONG gesture ---
        elif (self.supports(GestureType.LONG) and (long_click_dur := self.get_attr("long_click_duration")) is not None
              and duration > long_click_dur):
            gesture = GestureType.LONG

        # --- CORNER_TOP gesture ---
        elif (self.supports(GestureType.CORNER_TOP) and (corner_dim := self.get_attr("corner_dim")) is not None
              and cls.SCREEN_DIM is not None and (start_pos[0] >= cls.SCREEN_DIM[0] - corner_dim and start_pos[1] <= corner_dim)):  #pylint: disable=unsubscriptable-object  # Note this is a pylint bug
            gesture = GestureType.CORNER_TOP

        return gesture, distance, angle, velocity

    def is_single_click(self, gesture: GestureType) -> bool:
        """ Return True if gesture-type is always single click (e.g. Long, Drag, Swipe)"""
        return gesture not in (self.get_attr("multi_click_gestures") or set())  # Gesture types that can't be par of multi-click/tap


class DeviceType(EnumNameMixin, Enum):
    """
    DeviceSpecs for different types of input devices
    Non-gesture attributes are inherited from DEFAULT when using 'get' method
    """

    DEFAULT = DeviceSpec(  # Template used for inheritance and for default
        device_name              = "Default",
        contact_type             = "Generic",
        gestures                 = {}, # empty: no gesture labels in default (since not inherited)
        double_click_timeout     = 0.45,
        long_click_duration      = 0.5,
        movement_threshold       = 10,
        swipe_velocity_threshold = 800,
        corner_dim               = 5,
        multi_click_gestures     = {GestureType.CLICKTAP, GestureType.CORNER_TOP},
    )

    MOUSE = DeviceSpec(
        device_name              = "Mouse",
        contact_type             = "Button",
        gestures={
            GestureType.CLICKTAP:   "Click",
            GestureType.DRAG:       "Drag",
            GestureType.SWIPE:      "Swipe",
            GestureType.LONG:       "Long Click",
            GestureType.CORNER_TOP: "Top Corner",
        },
        DEFAULT=DEFAULT,
    )

    TOUCH = DeviceSpec(
        device_name              = "Touch",
        contact_type             = "Finger",
        gestures={
            GestureType.CLICKTAP:    "Tap",
            GestureType.DRAG:        "Drag",
            GestureType.SWIPE_LEFT:  "Swipe Left",
            GestureType.SWIPE_RIGHT: "Swipe Right",
            GestureType.SWIPE_UP:    "Swipe Up",
            GestureType.SWIPE_DOWN:  "Swipe Down",
            GestureType.LONG:        "Long Tap",
            GestureType.CORNER_TOP:  "Top Corner"
        },
        double_click_timeout     = 0.3,
        long_click_duration      = 0.8,
        movement_threshold       = 15,
        swipe_velocity_threshold = 500,
        DEFAULT=DEFAULT,
    )

    UNKNOWN = DeviceSpec(
        device_name              = "UNKNOWN",
        contact_type             = "Unknown",
        gestures={g: g.name for g in GestureType},  # Default names
        DEFAULT=DEFAULT,
    )

    ANY = "ANY"  # Wildcard

    @property
    def spec(self) -> DeviceSpec:
        """Return the underlying DeviceSpec associated with this enum value."""
        return cast(DeviceSpec, self.value)

DeviceSpec.init_screen_dim()  # Set screen dimension
#-------------------------------------------------------------------------------
### Command type structures

## Commands Type Alias
CommandsType: TypeAlias = str | list[str | list[str]]
# CommandsType can be:
#    - Single command string (e.g., "ls -a -l")
#    - List of one or more commands in either of the 2 forms
#        - String form  (e.g., "ls -a -l")
#        - List of argv-style component string (e.g., ["ls", "-a", "-l"])
# Examples include:
#           "ls -a -l"
#           [["ls", "-a", "-l"]
#           [ "ls -l", ["echo", "hello"],...]#

class CommandsDict(TypedDict):  # Note not a real data class - really a TypeAlias with deeper level hinting
    """Class used to constrain the keys allowed when the value of CommandsUnion is a dictionary"""
    cmds: CommandsType
    msg: NotRequired[str | None]
    timeout: NotRequired[int | None]

CommandsUnion: TypeAlias = CommandsType | CommandsDict
# Either:
#    - CommandsType encoding one or more commands
#    - Dictionary with entries {"cmds": <CommandsType>, "msg": <string>, "timeout": <int>}
#      where the second entry is an (optional) message to print after launching commands
#      and the 3rd entry is an optional timeout in seconds for the commands

DEFAULT_COMMANDS_DICT: dict[str, CommandsUnion] = {}
# Mapping dictionary whose keys are normalized gesture identifiers of form:
#    N_[MOUSE|TOUCH|ANY]_M_[CLICK|TAP|DRAG|SWIPE|LONG|CORNER_TOP|ANY]
# where N and M are RangeNumbers, which can optionally be followed by '+' or '-'
# respectively meaning greater than or equal and less than or equal.
# Note that DRAG and SWIPE also take the optional suffixes _LEFT, _RIGHT, _UP, _DOWN
#
# Each value is a CommandsUnion
#
# **NOTE** When using wildcards, order DEFAULT_COMMANDS_DICT in the order of preferred matches
#          Typically, more restrictive to less restrictive or else the more restrictive
#          options may never apply

def is_CommandsType(obj: object, allow_empty: bool = False) -> bool:  #pylint: disable=too-many-return-statements
    """
    Check if value is a CommandsType, consisting either of:
      - A single command expressed as a string
      - List of one or more (non-empty) commands, in one of 2 forms
          - Single command expressed as a string (can be empty if allow_empty=True
          - Single command expressed as an argv-style lists (e.g., ["ls", "-a", "-l"])
    """
    if isinstance(obj, str):  # Single *non-empty* command as string
        return len(obj.strip()) > 0 or allow_empty

    if not isinstance(obj, list) or len(obj) == 0: # Reject non-list or empty list
        return False

    # List of one or more commands
    for cmd in obj:
        if isinstance(cmd, str):  # Single string command
            if len(cmd.strip()) == 0:  # Empty string
                return False
            continue # Valid
        if isinstance(cmd, list): # Argv-style list command
            if len(cmd) == 0:  # Empty list
                return False
            if not all(isinstance(arg, str) for arg in cmd) or len(cmd[0].strip()) == 0:
                return False  # Must be all strings with first one non-empty
            continue   # Valid
        return False
    return True

def is_CommandsUnion(obj: object) -> bool:  #pylint: disable=too-many-return-statements
    """
    Returns True if value is compatible with CommandsUnion type, i.e., either:
        - CommandsType: list[str | list[str]]
        - CommandsDict: Dictionary with keys 'cmds' (CommandsType) and optional 'msg' (str) and 'timeout' (int) in seconds
    """
    if is_CommandsType(obj, allow_empty=True): # Just a CommandsType (allow top-level empty command)
        return True

    # Dict form: {"cmds": ..., "msg"?: str, "timeout"?: int}
    if isinstance(obj, dict):
        if not {'cmds'} <= obj.keys() <= {'cmds', 'msg', 'timeout'}:  # 'cmds' required, 'msg' & 'timeout' optional
            return False
        if not is_CommandsType(obj['cmds']):
            return False

        # Optional fields
        if 'msg' in obj and not isinstance(obj['msg'], str):  # If 'msg' key, its value must be a string
            return False
        if 'timeout' in obj and not isinstance(obj['timeout'], int) and not obj['timeout'] >= 0:  # If 'timeout' key, its value must be a non-negative integer
            return False
        return True
    return False

#-------------------------------------------------------------------------------
# RangeNumber class is used to represent pseudo numbers like greater/less than or equal to N

class RangeNumber:
    """
    An integer with optional range semantics:
      - 'N+' means N or greater
      - 'N-' means N or less
      - 'N' (no sign) means exactly N

    Equality:
      - RangeNumber vs int: Uses range semantics
      - RangeNumber vs RangeNumber: Signs and values must match

    Ordering (<, <=, >, >=) is based on subset/superset logic:
      - self <= other: the set of integers represented by self is a subset of other
      - self < other: the set of integers represented by self is a proper subset of other

    Examples:
        RangeNumber("5")    -> exact 5
        RangeNumber("5+")   -> 5 or more
        RangeNumber("5-")   -> 5 or less
    """

    __slots__ = ("number", "range")  # range: None, '+', '-'

    def __init__(self, s: str | int) -> None:
        """Initialize from string or int"""
        if isinstance(s, int):
            self.number = s
            self.range = None
        elif isinstance(s, str):
            s = s.strip()
            if s[-1] in ('+', '-'):
                self.range = s[-1]
                self.number = int(s[:-1])  # Will raise ValueError if invalid
            else:
                self.range = None
                self.number = int(s)
        else:
            raise TypeError(f"Cannot construct RangeNumber from {type(s)}")

    def __str__(self) -> str:
        """Human-readable string representation"""
        return f"{self.number}{self.range or ''}"

    def __repr__(self) -> str:
        "Debugging representation"
        return f"RangeNumber('{self}')"

    def __hash__(self) -> int:
        """Fast hash encoding"""
        return self.number * 3 + ({'+': 1, '-': 2, None: 0}.get(self.range, 0))

    @property
    def bounds(self) -> tuple[float, float]:
        """Return (lower_bound, upper_bound) tuple"""
        if self.range == '+':
            return self.number, inf
        if self.range == '-':
            return -inf, self.number
        return self.number, self.number

    def _subset_compare(self, other: RangeNumber) -> tuple[bool, bool]:
        """Check subset/superset relation"""
        self_lo, self_hi = self.bounds
        other_lo, other_hi = other.bounds
        is_subset = self_lo >= other_lo and self_hi <= other_hi
        is_superset = self_lo <= other_lo and self_hi >= other_hi
        return is_subset, is_superset

    def __eq__(self, other: Any) -> bool:
        """Equality with int or RangeNumber"""
        if isinstance(other, RangeNumber):
            return self.number == other.number and self.range == other.range
        if isinstance(other, int):
            lo, hi = self.bounds
            return lo <= other <= hi
        return NotImplemented

    def __lt__(self, other: RangeNumber | int) -> bool:
        if isinstance(other, int):
            _, hi = self.bounds
            return hi < other
        if isinstance(other, RangeNumber):
            is_subset, _ = self._subset_compare(other)
            return is_subset and self != other
        return NotImplemented

    def __le__(self, other: RangeNumber | int) -> bool:
        if isinstance(other, int):
            _, hi = self.bounds
            return hi <= other
        if isinstance(other, RangeNumber):
            is_subset, _ = self._subset_compare(other)
            return is_subset
        return NotImplemented

    def __gt__(self, other: RangeNumber | int) -> bool:
        if isinstance(other, int):
            lo, _ = self.bounds
            return lo > other
        if isinstance(other, RangeNumber):
            _, is_superset = self._subset_compare(other)
            return is_superset and self != other
        return NotImplemented

    def __ge__(self, other: RangeNumber | int) -> bool:
        if isinstance(other, int):
            lo, _ = self.bounds
            return lo >= other
        if isinstance(other, RangeNumber):
            _, is_superset = self._subset_compare(other)
            return is_superset
        return NotImplemented

    def __match_args__(self) -> tuple[str, str]:
        """Enable match-case logic"""
        return ("number", "range")

    @classmethod
    def is_range_number(cls, s: str) -> bool:
        """Check if string is valid RangeNumber: N, N+, N-"""
        try:
            cls(s)
            return True
        except (ValueError, TypeError):
            return False


#-------------------------------------------------------------------------------
### Gesture Command Class

## Create reverse lookup from gesture-type strings to GestureType
# Note this can't be inside the class since class uses slots and this is a dict which is mutable
_GESTURE_NAME_TO_TYPE: dict[str, GestureType] = {  # Map gesture name strings in each DeviceType gesture back to its GestureType
    **{
        name.upper(): gt
        for dt in DeviceType if isinstance(dt.spec, DeviceSpec) and not dt in (DeviceType.ANY, DeviceType.DEFAULT)
        for gt, name in dt.spec.gestures.items()
    },
    **{ # Mapping from GestureType name back to the GestureType enum
        gt.name.upper(): gt
        for gt in GestureType if gt is not GestureType.ANY
    }
}
debug(4, f"GESTURE_NAME_TO_TYPE={[f'{key}->{value.name}' for key, value in _GESTURE_NAME_TO_TYPE.items()]}" + '\n')

## Create reverse lookup from device_type names to DEVICE_TYPE
# Note this can't be inside the class since class uses slots and this is a dict which is mutable
_DEVICE_NAME_TO_TYPE: dict[str, DeviceType] = {  # Map device_name strings to (first) instance of corresponding DeviceType
        dt.spec.device_name.upper(): dt
        for dt in DeviceType if isinstance(dt.spec, DeviceSpec) and not dt in (DeviceType.ANY, DeviceType.DEFAULT)
    }
debug(4, f"DEVICE_NAME_TO_TYPE={[f'{key}->{value.name}' for key, value in _DEVICE_NAME_TO_TYPE.items()]}" + '\n')

@dataclass(slots=True)
class GestureCommand:
    """
    Class for parsing and storing gesture commands that can be used to map a specific gesture
    definition (including: device type, number/list of contacts, number of clicks, gesture type)
    to one or more executable commands.
    """
    device_type: DeviceType = DeviceType.ANY      # Note DeviceType.ANY is the wildcard device
    contacts_num: RangeNumber | None = None       # For Touch (only number of fingers matter)
    contacts_members: set[int] | None = None      # For Mouse (individual buttons are specified)
    num_clicks: RangeNumber = field(default_factory=lambda: RangeNumber("1+"))  # Default is any number of clicks/taps
    gesture_type: GestureType = GestureType.ANY   # Note that GestureType.ANY is the gesture wildcard
    cmds_dict: CommandsDict | None = None

    def __post_init__(self) -> None:
        """Normalize to convert integer to RangeNumber"""
        if isinstance(self.contacts_num, int):
            self.contacts_num = RangeNumber(self.contacts_num)
        if isinstance(self.num_clicks, int):
            self.num_clicks = RangeNumber(self.num_clicks)

    # Holds all loaded and parsed instances of Gesture Commands from external file and/or COMMANDS_DICT
    GESTURE_CMDS_LIST: ClassVar[list[GestureCommand]] = []
    # Note that earlier matching keys override later matching keys
    # So later we will first load external file, then internal COMMANDS_DICT

    @property
    def cmds(self) -> CommandsType | None:
        """Return the CommandsType element"""
        cmds_dict = self.cmds_dict
        return cmds_dict["cmds"] if cmds_dict is not None else None

    @property
    def msg(self) -> str | None:
        """Return the Message element"""
        cmds_dict = self.cmds_dict
        return cmds_dict["msg"] if cmds_dict is not None else None

    @property
    def timeout(self) -> int | None:
        """Return the Timeout element"""
        cmds_dict = self.cmds_dict
        return cmds_dict["timeout"] if cmds_dict is not None else None

    def sprint_contacts(self, button_names: bool = True) -> str:
        """Return human readable list of contact members if present, otherwise number of contacts"""
        if self.contacts_members is not None:
            if isinstance(self.device_type.spec, DeviceSpec) and self.device_type.spec.get_attr("contact_type").upper() == "BUTTON":
                contact_list_int = sorted(self.contacts_members)
                contact_list_str =  [MouseButton.safe_name(n) if button_names else str(n) for n in contact_list_int]  # Returns button name or number if can't find name or button_names in False
                return "[" + ",".join(contact_list_str) + "]"
            return str(len(self.contacts_members))  # If touch device then numbers in contact_members are not identifiable so just use count
        return str(self.contacts_num or RangeNumber("1+"))  # Otherwise, return number of contacs (with default being the wildcard '1+')

    def __str__(self) -> str:
        """
        Return canonical string representation of gesture type (with button names where applicable)
        """
        return self.sprint_gesture(True)

    def sprint_gesture(self, button_names: bool = True) -> str:
        """
        Return canonical string representation of gesture type.
        Translate button numbers to names if button_names is True (default)
        Format is: <Contacts>_<DeviceType>_<NumClicks>_<GestureType>
        where:
           <Contacts> is either a RangeNumber or a list of contacts (including button names) if for a Mouse
           <NumClicks> is a RangeNumber
        Examples:
            [Left, Right]_MOUSE_3_CLICKTAP
            3_TOUCH_1_LONG
        """
        contacts_str = self.sprint_contacts(button_names)
        return f"{contacts_str}{GESTURE_SEP}{self.device_type}{GESTURE_SEP}{self.num_clicks}{GESTURE_SEP}{self.gesture_type}"

    def sprint_friendly_gesture(self, button_names: bool = True) -> str:
        """
        Return friendly string representation of gesture type
        Translate button numbers to names if button_names is True (default)
        Format is: <Contacts>_<DeviceName>_<NumClicks>_<GestureName>
        where:
           <Contacts> is either a RangeNumber or a list of contacts (including button names) if for a Mouse
           <NumClicks> is a RangeNumber
        Examples:
            [Left,Right]_Button_3_Click
            3_Finger_1_Long Tap
        """
        contacts_str = self.sprint_contacts(button_names)

        if isinstance(self.device_type.spec, DeviceSpec):
            contact_type = self.device_type.spec.get_attr("contact_type")
            gesture_str = self.device_type.spec.gestures.get(self.gesture_type, "UNKNOWN") if self.gesture_type is not GestureType.ANY else "ANY"
        else:
            contact_type = "Any"  # Can't determine without device type
            gesture_str = self.gesture_type.value_str if self.gesture_type is not GestureType.ANY else str(self.gesture_type)

        return f"{contacts_str}{GESTURE_SEP}{contact_type}{GESTURE_SEP}{self.num_clicks}{GESTURE_SEP}{gesture_str}"

    def sprint_commands(self) -> str:
        """Print out CommandsType attribute as string"""
        cmds = self.cmds
        if cmds is None:
            return ""
        return '"' + cmds.replace('"', r'\"') + '"' if isinstance(cmds, str) else str(cmds)

    def matches_rule(self, other: GestureCommand) -> bool:
        """
        Return true if self matches another GestureCommand
        Note this is not symmetric since wildcards are appended only to 'other'
        """
        device_type_matches = other.device_type in (self.device_type, DeviceType.ANY) # Devices match or other is GestureType.ANY
        if not device_type_matches:
            return False

        contacts_match =((self.contacts_members is None and self.contacts_num == other.contacts_num) or # Self contacts range number equals other contacts range number
                         (self.contacts_members is not None and (
                             (other.contacts_members is not None and self.contacts_members == other.contacts_members) or  # Both contacts_members sets are non-None and match
                             (other.contacts_members is None and len(self.contacts_members) == other.contacts_num))))    # Number self members is in the "subrange" of other contacts number
        if not contacts_match:
            return False

        clicks_match = other.num_clicks == self.num_clicks # Range numbers of clicks are equal
        if not clicks_match:
            return False

        gestures_match =  other.gesture_type in (self.gesture_type, self.gesture_type.base_type, GestureType.ANY)  # Other matches gesture, its base or ANY
        if not gestures_match:
            return False

        return True

    def lookup(self) -> GestureCommand | None:
        """
        Find the first entity in GESTURE_CMDS_LIST (ordered the same as <external command file> + COMMANDS_DICT)
        that matches the given GestureCommand, including wildcards
        """

        for cmd in GestureCommand.GESTURE_CMDS_LIST:
            if self.matches_rule(cmd):
                return cmd
        return None  # no match found

    def append_gesture_command_list(self, add_overridden: bool = False) -> GestureCommand | None:
        """
        Append new gesture_command to end of GESTURE_CMDS_LIST if not overridden by
        prior same or more general gesture or if add_overridden is True.
        Returns first prior overriding gesture if one exist otherwise None.
        """
        prior_match = self.lookup()
        if prior_match is None or add_overridden:
            type(self).GESTURE_CMDS_LIST.append(self)
        return prior_match

    @classmethod
    def clear_gesture_command_list(cls) -> None:
        """Clear GESTURE_CMDS_LIST list"""
        cls.GESTURE_CMDS_LIST.clear()

    @classmethod
    def dedupe_gesture_command_list(cls) -> None:
        """ Remove duplicate gesture command entries (starting from end of list as list is read going forward)"""
        seen = set()
        new_list = []
        for cmd in reversed(cls.GESTURE_CMDS_LIST):
            key = str(cmd)
            if key not in seen:
                seen.add(key)
                new_list.append(cmd)
        cls.GESTURE_CMDS_LIST = new_list[::-1]  # preserve original order

    #---- Gesture Command Parsing Regex's ---
    _DEVICE_TYPE_PATTERN = "|".join({re.escape(dt.name) for dt in DeviceType if dt is not DeviceType.DEFAULT})
    debug(4, f"DEVICE_TYPE_PATTERN={_DEVICE_TYPE_PATTERN}" + '\n')

    # _GESTURE_NAMES_PATTERN = "|".join({ # Iterate over all gesture string values for all DeviceTyp, escape entries and join into regex string
    #     re.escape(gs) for dt in DeviceType
    #     if dt not in(DeviceType.UNKNOWN, DeviceType.ANY)
    #     for gs in (dt.spec.gestures or {}).values()
    # } | {"ANY"})

    # Alternatively:
    _GESTURE_NAMES_PATTERN = "|".join({ # As above but include additionally the GestureType name strings
        re.escape(gs) for dt in DeviceType
        if dt not in(DeviceType.UNKNOWN, DeviceType.ANY)
        for gs in list(gt.name for gt in dt.spec.gestures.keys()) + list(dt.spec.gestures.values())
    } | {"ANY" })
    debug(4, f"GESTURE_NAMES_PATTERN={_GESTURE_NAMES_PATTERN}" +'\n')

    GESTURE_KEY_PATTERN = re.compile(
        r"(?P<contacts>\[[A-Za-z\s\d,_-]+\]|\d+[+-]?)" + GESTURE_SEP +
        rf"(?P<device_type>{_DEVICE_TYPE_PATTERN})" + GESTURE_SEP +
        r"(?P<num_clicks>\d+[+-]?)" + GESTURE_SEP +
        rf"(?P<gesture>{_GESTURE_NAMES_PATTERN})",
        flags=re.IGNORECASE)

    @staticmethod
    def _parse_gesture_key(key_str: str) -> tuple[DeviceType, RangeNumber | None, set[int] | None, RangeNumber, GestureType]:
        """Parse and fully validate a COMMANDS_DICT gesture string key.
        Returns parsed components on success, None on failure.
          - Device type (dev_type)
          - Number of contacts (contacts_num)
          - Contact members (contacts_members)
          - Number of clicks/taps (num_clicks)
          - Gesture type gesture_type
        Raises ValueError with helpful message on invalid input (preserves original behavior).
        """
        m = GestureCommand.GESTURE_KEY_PATTERN.fullmatch(key_str.strip())
        if not m:
            raise ValueError(f"Invalid gesture string format: {key_str}")

        # --- DeviceType ---
        dev_type_raw = m.group("device_type").upper()  # Normalize
        if dev_type_raw == "ANY":
            dev_type = DeviceType.ANY
        else:
            try:
                dev_type = _DEVICE_NAME_TO_TYPE[dev_type_raw]
            except KeyError as e:
                raise ValueError(f"Unknown device type: {dev_type_raw!r}") from e

        # --- gesture ---
        gesture_raw = m.group("gesture").upper()  # Normalize
        if gesture_raw == "ANY":
            gesture_type = GestureType.ANY
        else:
            try:
                gesture_type = _GESTURE_NAME_TO_TYPE[gesture_raw]

            except KeyError as e:
                raise ValueError(f"Unknown gesture name: {gesture_raw!r}") from e

        # --- num_clicks ---
        num_clicks_raw = m.group("num_clicks")
        try:
            num_clicks = RangeNumber(num_clicks_raw)
            if num_clicks < 1:
                raise ValueError()
        except (TypeError, ValueError) as e:
            raise ValueError(f"Number of clicks must be N, N+ or N- where N>1: {num_clicks_raw}") from e

        # Validation for gesture_type
        if gesture_type is not GestureType.ANY and isinstance(dev_type.spec, DeviceSpec) and dev_type not in (DeviceType.DEFAULT, DeviceType.UNKNOWN):
            # Gesture_raw has to match either a GestureType or its friendly name in the device-specific gestures list
            if not (
                    (gesture_raw in GestureType.__members__ and GestureType[gesture_raw] in dev_type.spec.gestures) # gesture_raw is a DeviceType name and is a gesture for the device
                    or (gesture_type in dev_type.spec.gestures and dev_type.spec.gestures[gesture_type].upper() == gesture_raw)): # gesture_raw is the friendly name for gesture_type in the device
                raise ValueError(f"Invalid gesture type for {dev_type.name}: {gesture_raw!r}")
            if num_clicks > 1 and dev_type.spec.is_single_click(gesture_type):
                raise ValueError(f"Multi-click not supported on {dev_type.name} for: {gesture_raw!r}")

        # --- contacts: Can be absolute number or for mouse can also be list of button numbers and/or names
        contacts_raw = m.group("contacts").strip().upper()

        contacts_num: RangeNumber | None = None
        contacts_members: set[int] | None = None

        if RangeNumber.is_range_number(contacts_raw):
            contacts_num = RangeNumber(contacts_raw)
            if contacts_num < 1:
                raise ValueError(f"Number of contacts pressed or touched must be positive: {contacts_num}")
        elif isinstance(dev_type, DeviceType) and dev_type is DeviceType.MOUSE:  #Mouse can also specify buttons by list of name or numbers (e.g., [1,2,Right])
            if not contacts_raw.startswith("[") or not contacts_raw.endswith("]"):
                raise ValueError(f"Mouse button list must be in [X1, X2, X3,...] form where the elements are either button numbers or names: {contacts_raw}")
            inside = contacts_raw[1:-1]  # Remove outer brackets
            items = [item.strip() for item in inside.split(",") if item.strip()]  # Clean up white leading and trailing whitespace between elements; removes empty ones
            contacts_members = set()
            for item in items:
                if item.isdigit():  # Try button *number* first
                    val = int(item)
                else:  # Lookup button name
                    try:
                        val = MouseButton[item.title()].value
                    except KeyError as exc:
                        raise ValueError(f"Invalid mouse button name or number: {item}") from exc
                contacts_members.add(val)
        else:
            raise ValueError(f"Invalid contact format for device {dev_type}: {contacts_raw}")

        return dev_type, contacts_num, contacts_members, num_clicks, gesture_type

    @staticmethod
    def _parse_command_value(value: Any) -> CommandsDict:
        """
        Returns the corresponding CommandsDict object with "cmds" and optional "msg" and "timeout" keys.
        If not a valid CommandsUnion object, then raises an exception.
        """
        if not is_CommandsUnion(value):
            raise ValueError(f"Invalid dictionary command format: {value!r}")

        # At this point, we KNOW it's valid — now extract cleanly
        if isinstance(value, dict):  # Command is of form {"cmds": <CommandsType>, "msg": <string>, "timeout": <int>}
            cmds: CommandsType = value["cmds"]
            msg: str | None = value.get("msg")
            timeout: int | None = value.get("timeout")
        else: # value is just a CommandsType
            if isinstance(value, str) and value == "":
                value = None # No-op
            cmds = value
            msg = None
            timeout = None

        return { "cmds": cmds, "msg": msg, "timeout": timeout }

    @classmethod
    def _parse_add_gesture_command(cls, key_str: str, raw_value: Any, add_overridden: bool = False) -> bool:
        """
        Parse a single gesture command from key, value and append to GESTURE_CMDS_LIST (allows duplicates)
        Won't add if new gesture command is overridden by earlier added one *unless* add_overridden set True.
        Returns True on success.
        """
        try:
            # 1. Validate key
            dev_type, contacts_num, contacts_members, num_clicks, gesture_type = cls._parse_gesture_key(key_str)

            # 2. Validate value
            cmds_dict = cls._parse_command_value(raw_value)

            gesture_cmd = cls(
                device_type         = dev_type,
                contacts_num        = contacts_num,
                contacts_members    = contacts_members,
                num_clicks          = num_clicks,
                gesture_type        = gesture_type,
                cmds_dict           = cmds_dict,
            )

            prior_match = gesture_cmd.append_gesture_command_list(add_overridden)
            if prior_match is not None:
                debug(1, f"WARNING: Gesture masked by earlier entry ({"loading anyway" if add_overridden else "dropped"}): {gesture_cmd.sprint_gesture()} < {prior_match.sprint_gesture()}")
            if prior_match is None or add_overridden:
                debug(4, f"Loaded command for gesture: {gesture_cmd}")
                return True

        except Exception as e:
            debug(1, f"WARNING: Failed to parse '{key_str}': {e}")

        return False

    @classmethod
    def parse_and_load_dict(cls, commands_dict: dict[str, CommandsUnion], *, source: str = "default dictionary", dropped_keys: int = 0, add_overridden: bool = False) -> None:
        """
        Parse and append existing gesture command dictionary into GestureCommand instances
        stored in GESTURE_CMDS_LIST list. Note: newer keys have lower precedence than older keys
        Pass optional number of dropped duplicates (or other parsed errors) that were dropped and not parsed.
        """
        seen = 0
        added = 0
        for key_str, value in commands_dict.items():
            seen +=1
            if cls._parse_add_gesture_command(key_str, value, add_overridden):
                added +=1
        debug(2, f"#Loaded {added}/{seen + dropped_keys} gesture commands from {source} to GESTURE_CMDS_LIST (size={len(cls.GESTURE_CMDS_LIST)})")

    @classmethod
    def parse_and_load_file(cls, file_path: str | None, *, add_overridden: bool = False) -> None:
        """
        Load external gesture command JSON-like file and append onto GESTURE_CMDS_LIST list.
        Each entry is a key-value pair of form:  <gesture_string>: <CommandsUnion>.
        Note: newer keys have lower precedence than older keys
        Any text on line after '#' is treated as a comment
        Any single escaped '#' is double-escaped so valid JSON and not treated as comment

        Note the entries can be entered in any of the following ways
          1. JSON dictionary of <gesture string>: <CommandsUnion>  pairs, separated by commas
          2. Same as #1 but without enclosing starting and ending braces
          3. JSON dictionary with at least one key called "gestures" whose value is a dictionary or list of strings
             of key-value pairs of form #1 (Used to parse the 'options.json' file in HA add-ons)

        Note: Unlike conventional JSON, a trailing comma on the last key-value pair entry is allowed in #1 and #2
        Note: File paths are relative to current working directory
        """

        def strip_comments(line: str) -> str:
            """"Delete portion of line following an escaped '#' and clean up trailing white space"""
            pos = 0
            while True:
                pos = line.find("#", pos)
                if pos == -1:
                    return line.rstrip()  # No unescaped '#', so just clean up trailing white space
                if pos != 0 and line[pos - 1] == "\\":   # Found '\#'
                    line = line[:pos-1] + '\\\\' + line[pos:]  # Replace '\#' with '\\#' to avoid JSON parse errors
                    pos +=2  # Skip past new '#' position
                    continue
                return line[:pos].rstrip()

        T = TypeVar("T")
        def unescape_hashes(obj: T) -> T:
            """Remove '\' that were added by strip_comments to avoid JSON parse errors"""
            if isinstance(obj, str):
                return cast(T, obj.replace(r"\#", "#"))
            if isinstance(obj, list):
                return cast(T, [unescape_hashes(x) for x in obj])
            if isinstance(obj, dict):
                return cast(T, {k: unescape_hashes(v) for k, v in obj.items()})
            return obj

        _dropped_dups: int  = 0 # Tracks number of entries dropped as duplicated by JSON parser (when reading from file)
        def keep_first_instance(pairs: list[tuple[str, Any]]) -> dict[str, Any]:
            """JSON parser helper so that discards rather than overwrites duplicate keys"""
            seen = set()
            result: dict[str, Any] = {}
            for k, v in pairs:
                if k in seen:
                    nonlocal _dropped_dups
                    _dropped_dups +=1
                    debug(1, f"WARNING: File contains exact duplicate keys, dropping all but first instance: {k}")
                else:
                    seen.add(k)
                    result[k] = v
            return result

        def get_key_value_text(text: str, key: str) -> str | None:
            """
            Return raw JSON value corresponding to 'key', if exists and is a dict or list, otherwise return None
            Note if list, then strip off enclosing quotations for each line
            """
            pattern = rf'"{re.escape(key)}"\s*:\s*(\{{|\[)'   # Match "<key":<whitespace><[ or {>
            match = re.search(pattern, text)
            if not match:
                return None

            start = match.end() - 1  # position of '{'
            opening = text[start]  # '{' if dict, '[' if list
            closing = '}' if opening == '{' else ']'

            lines_before_start = text[:start+1].count('\n')
            i = start + 1
            n = len(text)
            depth = 1
            in_string = False

            while depth > 0 and i < n:
                c = text[i]
                if in_string:  # Ignore closing braces in strings
                    if c == '\\':  #Skip escaped character
                        i += 1
                    elif c == '"':  # End string
                        in_string = False
                else:
                    if c == '"':  # Start string
                        in_string = True
                    elif c == opening:
                        depth += 1
                    elif c == closing:
                        depth -=1
                i += 1
            if i == n:
                return None  # Malformed dict or list

            text = text[start+1:i-1] # Value of key (stripped of enclosing braces or brackets)
            if opening == '[':  # Convert list of strings containing key-value pairs to dictionary of key-value pairs
                text = re.sub(r'(?<!\\)"', '', text)  # Remove unescaped quotes
                text = text.replace(r'\"', '"') # Replace: \" -> "
                text = text.replace('\\\\', '\\') # Replace: \\" -> \  (unescape escapes)
            return '\n' * lines_before_start + '{' + text + '}' # Prepend blank lines to preserve line numbering and enclose in bracesg1

        # Check existence and readability
        if file_path is None:  # Return without error if no file given
            return
        if not os.path.isfile(file_path) or not os.access(file_path, os.R_OK):
            abs_path = os.path.abspath(os.path.expanduser(file_path))
            debug(1, f"WARNING: Gesture commands file '{abs_path}' does not exist or is not readable...")
            return

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                lines = [strip_comments(line) for line in f]  # Strip comments

            text = "\n".join(lines).rstrip()  # Join and remove trailing white space
            text = get_key_value_text(text, "gestures") or text # Assign to value of 'gestures' key if present or else original text
            if not text.lstrip().startswith("{"):  # Add enclosing braces if missing
                text = "{" + text + "}"
            text = re.sub(r',\s*}\s*$', '}', text)  # Remove trailing white space and any final comma before '}'
            _dropped_dups = 0
            data = json.loads(text, object_pairs_hook=keep_first_instance) # Load text as is
            data = unescape_hashes(data)  # Remove added escape before escaped hashes

        except json.JSONDecodeError as e:
            debug(0, f"JSON syntax error in '{file_path}': line {e.lineno}: {e.msg}",)
            return
        except Exception as e:
            debug(0, f"ERROR: Failed to read gesture commands file '{file_path}: {e}")
            return

        if not isinstance(data, dict):
            debug(0, f"ERROR: Gesture commands file '{file_path}' must contain a top-level dictionary...")
            return

        cls.parse_and_load_dict(data, source=f"'{file_path}'", add_overridden=add_overridden, dropped_keys = _dropped_dups)

    @classmethod
    def initialize_gesture_command_list(cls, file_list: list[str] | None=None, *, add_overridden: bool = False) -> None:
        """Load external gesture command file, then default internal gesture command file, then dedupe and pretty-print"""
        cls.clear_gesture_command_list()
        if file_list is not None:
            for file in file_list:
                cls.parse_and_load_file(file, add_overridden = add_overridden)
        cls.parse_and_load_dict(DEFAULT_COMMANDS_DICT, add_overridden = add_overridden)
        debug(1,'\n' + cls.pretty_parsed_keys_table() + '\n')

    @classmethod
    def pretty_parsed_keys_table(cls) -> str:
        """Return a nicely formatted, table-like string of all GestureCommand.GESTURE_CMDS_LIST"""
        if not GestureCommand.GESTURE_CMDS_LIST:
            return "GESTURE_CMDS_LIST is empty."

        intercolumn_space = 2  # Space between columns
        ## Header width calculation:
        gesture_width = len("Gesture")
        cmd_width = len("Command")
        msg_width = len("Message")
        timeout_width = len("Time")

        formatted_rows = []  # List of the formatted strings for each GestureCommand: N-MODALITY_M-GESTURE
        for cmds_dict in cls.GESTURE_CMDS_LIST:         # Create the formatted string for the first 4 columns
            gesture_str = cmds_dict.sprint_gesture(button_names = False)
            cmds_str = cmds_dict.sprint_commands()
            msg_str = cmds_dict.msg or "-"
            timeout_str = str(cmds_dict.timeout) if cmds_dict.timeout is not None else "-"

            formatted_rows.append((gesture_str, cmds_str, msg_str, timeout_str))

            # Update maximum column widths
            gesture_width = max(gesture_width, len(gesture_str))
            cmd_width = max(cmd_width, len(cmds_str))
            msg_width = max(msg_width, len(msg_str))
            timeout_width = max(timeout_width, len (timeout_str))

        space_str = ' ' * intercolumn_space
        separator = ('-' * gesture_width) + space_str + ('-' * cmd_width) + space_str + ('-' * msg_width) + space_str + ('-' * timeout_width)

        #Add inter-columnar space
        gesture_width += intercolumn_space
        cmd_width += intercolumn_space
        msg_width += intercolumn_space

        lines = [] # Build the table
        header = f"{'Gesture':^{gesture_width}}{'Command':^{cmd_width}}{'Message':^{msg_width}}{'Time':^{timeout_width}}"
        lines.append(header)
        lines.append(separator)

        for gesture_str, cmds_str, msg_str, timeout_str in formatted_rows:  # Data rows
            lines.append(f"{gesture_str:<{gesture_width}}"
                         f"{cmds_str:<{cmd_width}}"
                         f"{msg_str:^{msg_width}}"
                         f"{timeout_str:^{timeout_width}}")

        return "\n".join(lines)

#-------------------------------------------------------------------------------
### Contact Group Class

EventRecord: TypeAlias = tuple[float, tuple[int, int], ContactState]

#Moved the follow 2 dictionaries outside the class to allow  slots=True

class ContactGroup(RegistryMixin):
    """
    Summarize all the contact events for a single "click" for a given device_id from
    first ButtonPress/TouchBegin contact to last ButtonRelease/TouchEnd end of contact.
    Built via add_state(). Finalized when all contacts released.
    Note: each group should start with a PRESS state, have one or more intermediate, PRESS/RELEASE/MOTION states and end in a RELEASE state
    """
    _last_group_added: dict[int, "ContactGroup" | None] = {}  # Dictionary of last group added per device_id
    _prev_group_added: dict[int, "ContactGroup" | None] = {}  # Dictionary of next to last group added per device_id


    def __init__(self, device_id: int, dev_type: DeviceType, contact_id: int, contact_time: float, contact_pos: tuple[int, int]) -> None:
        self.device_id: int = device_id                  # id for input device (same as in xinput --list)
        self.device_type: DeviceType = dev_type          # DeviceType: MOUSE or TOUCH
        self.first_contact_id: int = contact_id          # id for first contact (button or finger)
        self.start_time: float = contact_time            # Time of first button or finger contact
        self.end_time: float | None = None               # Time of last button or finger contact release
        self.start_pos: tuple[int, int] = contact_pos    # Initial position of first contact
        self.current_pos: tuple[int, int] = contact_pos  # Current position of first contact (only updates position of first contact, not other fingers)

        self.path: dict[int, list[EventRecord]] = {}
        # Path dictionary indexed by 'contact_id' (i.e., 'detail' corresponding to button or finger number),
        # showing the sequence of Press, Release and Motion events for all contacts in the ContactGroup
        # Each entry is a list of EventRecords consisting of: (time, pos, state}
        self.last_event: EventRecord | None = None       # Last event entry (regardless of contact)
        self.current_pressed: list[int] = []             # List of current contact_id's currently in 'Press' state
        self.peak_contacts: int = 0                      # Maximum number of simultaneous contacts in 'Press' state at any time during the contact
        self.peak_contacts_members: set[int] = set()     # List of current contact_ids during first instance of peak_contacts

        self.add_event(contact_id, contact_time, contact_pos, ContactState.PRESS)  # Add initial 'Press' event
        self.id: tuple[int, uuid.UUID] = (self.device_id, uuid.uuid4())  #  Unique id, partially indexed by device_id for use in registry
        if not self.is_registered():
            self.register(self)                      # Register in class registry

        cls = type(self)
        cls._prev_group_added[device_id] = cls._last_group_added.get(device_id)  # Update dictionary of previous group added per device
        cls._last_group_added[device_id] = self                                  # Update  dictionary of last group added per device

    @classmethod
    def last_group_added(cls, device_id: int) -> ContactGroup | None:
        """Return last contact group added for device_id"""
        return cls._last_group_added.get(device_id)

    @classmethod
    def prev_group_added(cls, device_id: int) -> ContactGroup | None:
        """Return previous (next to last) contact group added for device_id"""
        return cls._prev_group_added.get(device_id)

    @staticmethod
    def unregister_all(device_id: int) -> None:
        """Unregister all ContactGroup members associated with device_id"""
        with _registry_lock:
            reg = cast(dict[tuple[int, uuid.UUID], "ContactGroup"], ContactGroup._registry())  # Keeps mypy happy
            for key in list(reg.keys()):
                dev_id, _ = key
                if dev_id == device_id:
                    ContactGroup.unregister(key)

    def add_event(self, contact_id: int, contact_time: float, contact_pos: tuple[int, int], state: ContactState) -> None:
        """Add event for contact_id consisting of current: time, position and state of the specific contact"""
        if contact_id not in self.path:  # Add event to path
            self.path[contact_id] = []

        self.last_event = (contact_time, contact_pos, state)
        self.path[contact_id].append(self.last_event)  # Append new event

        if state is ContactState.PRESS:
            self.current_pressed.append(contact_id)
            num_current_contacts = len(self.current_pressed)
            if num_current_contacts > self.peak_contacts:
                self.peak_contacts = num_current_contacts
                self.peak_contacts_members = set(self.current_pressed)

        elif state is ContactState.MOTION:
            pass  # Just add to path

        elif state is ContactState.RELEASE:
            if contact_id in self.current_pressed:
                self.current_pressed.remove(contact_id)
            if contact_id == self.first_contact_id:
                self.current_pos = contact_pos
            if not self.current_pressed:  # All contacts released
                self.end_time = contact_time

    @classmethod
    def is_active(cls, dev_id: int) -> bool:
        """ Return True if group is 'active' -- i.e., between press and release type events"""
        return (group := ContactGroup.last_group_added(dev_id)) is not None and not group.is_complete

    @property
    def is_complete(self) -> bool:
        """Return True if all contact_ids have been released"""
        return self.end_time is not None

    def get_peak_members(self) -> set[int]:
        """Return a copy of peak_contacts_members list"""
        return self.peak_contacts_members.copy()

    @property
    def duration(self) -> float:
        """Return time between first press and last release in the group"""
        return self.end_time - self.start_time if self.end_time is not None else 0

    @property
    def time_to_double_click_timeout(self) -> float:
        """Return time remaining until double click timeout"""
        return cast(float, self.device_type.spec.get_attr("double_click_timeout")) - (XInputParser.x_uptime() - self.start_time)

    @property
    def num_events(self) -> int:
        """Return number of events in the group"""
        return sum(len(path_list) for path_list in self.path.values())

    def classify_click(self) -> GestureData:
        """
        Classify a click based on device thresholds.
        Returns:
          - gesture: GestureType if determined, None if waiting for multi-click
          - distance: Euclidean distance in pixels
          - angle : Angle in degrees (0° = right, 90° = up)
          - velocity: pixels/sec
        """
        return self.device_type.spec.classify_click(self.duration, self.start_pos, self.current_pos)

    def __repr__(self) -> str:
        """Return debug string summary of ContactGroup entry for specified group associated with dev_id."""
        time_end_string = f" -> {truncate_time(self.end_time)} [{sec_to_ms(self.end_time - self.start_time)} ms]" if self.end_time else ""
        return (f"Group: dev={self.device_id}, type={self.device_type}, " +
                f"Events={self.num_events} " +
                f"Contacts={self.current_pressed} peak={self.peak_contacts} first={self.first_contact_id}:{self.start_pos}" +
                (f"->{self.current_pos} " if len(self.path) != 1 else " ") +
                f"Time: {truncate_time(self.start_time)}{time_end_string}")

    def sprint(self, append: str | None  = "") -> str:
        """Return indented version of __repr__ ready for debug printing"""
        return f"   {repr(self)}{append}"

#-------------------------------------------------------------------------------
### GestureSequence Class

@dataclass(slots=True)
class GestureSequence(RegistryMixin):
    """
    Sequence of related ContactGroups until break condition (Drag, Swipe, Long click or
    double_click_timeout or different contact set allows for closes-out of the gesture
    Contains only **completed** groups
    """

    def __init__(self, group: ContactGroup) -> None:
        """ Initialize using 'group' as the first group in the sequence"""
        self.device_id: int  = group.device_id                        # Set device_id to device_id of group
        self.device_type: DeviceType = group.device_type              # Set device_type to device_type of group
        self.groups: list[ContactGroup] = [group]                     # Populate with first group
        self.contacts_num: int = group.peak_contacts                  # Set (fixed) number of contacts to peak group contacts
        self.contacts_members: set[int] = group.get_peak_members()     # Set (fixed) contacts_members to peak group members
                                                                      # note this is only used for MOUSE where buttons are fixed
                                                                      # In contrast, for TOUCH each contact generates a new typically sequential number)
        self.id = self.device_id                                      # Unique since only one gesture sequence per device_id allowed
        if not self.is_registered():                                  # Register if not already registered (needed since we at times want to re-initialize)
            self.register(self)

    def can_append(self, group: ContactGroup) -> bool:
        """Return True if new group has same member list (if TOUCH) or same number of members (if MOUSE)"""
        if self.device_type is DeviceType.TOUCH:
            return group.peak_contacts == self.contacts_num  # For TOUCH just need number of peak contacts to match
        return group.get_peak_members() == self.contacts_members #For MOUSE exact list of peak buttons must match

    def append(self, new_group: ContactGroup) -> None:
        """Add a new ContactGrop to to the GestureSequence"""
        if new_group.device_id == self.device_id:  # Must have the same device_id
            self.groups.append(new_group)

    def pop(self) -> ContactGroup:
        """ Remove and return the last ContactGroup in the sequence. Raises IndexError if sequence is empty """
        if not self.groups:
            raise IndexError("Pop from empty GestureSequence")
        return self.groups.pop()

    def __repr__(self) -> str:
        """Return debug string summary of GestureSequence entry for dev_id."""
        parts = []
        for group in self.groups:
            sx, sy = group.start_pos
            ex, ey = group.current_pos
            parts.append(f"({sx}, {sy})->({ex}, {ey})")
        path = ", ".join(parts)

        return(f"Sequence: dev={self.device_id}, type={self.device_type}, Contacts={self.contacts_members} "
               f"Groups[{len(self.groups)}]: {path} ")

    @property
    def first_group(self) -> ContactGroup:
        """ Return last group in the sequence"""
        return self.groups[0]

    @property
    def last_group(self) -> ContactGroup:
        """ Return last group in the sequence"""
        return self.groups[-1]

    @property
    def start_time(self) -> float:
        """ Return sequence start time"""
        return self.groups[0].start_time

    @property
    def end_time(self) -> float | None:
        """ Return sequence end time"""
        return self.groups[-1].end_time

    @property
    def duration(self) -> float:
        """ Time between first contact and last release in the sequence"""
        end_time = self.end_time
        return end_time - self.start_time if end_time is not None else 0

    def closeout_sequence(self, gesture_data: GestureData) -> bool:
        """ Closeout existing gesture sequence and unregister sequence and associated groups
        Return True if gesture sequence closed out
        """

        with _registry_lock:
            num_groups = len(self.groups)
            if num_groups == 0:  # Sequence is blank, can't be closed out # Shouldn't happen
                return False

            gesture, duration, movement, velocity = gesture_data  #pylint: disable=unused-variable

            gesture_command = GestureCommand(self.device_type, RangeNumber(self.contacts_num), self.contacts_members, RangeNumber(num_groups), gesture) #pylint: disable=too-many-function-args
            gesture_str = gesture_command.sprint_friendly_gesture()
            debug(2, f"**RESULT: {gesture_str} [device={self.device_id}] "
                  f"seq_len={num_groups} contacts={self.contacts_num} duration={(self.duration * 1000):.1f}ms" +
                  (f" movement={movement} velocity={velocity}" if movement and velocity and self.device_type.spec.is_single_click(gesture_data[0]) else ""))
            debug(4, "   " + repr(self))

            ContactGroup.unregister_all(self.device_id)
            GestureSequence.unregister(self.id)

        gesture_command_match = gesture_command.lookup()  # Lookup gesture in command dictionary
        if gesture_command_match is not None:  #Match found
            if (cmds := gesture_command_match.cmds) is not None:
                debug(1, f">ACTION: gesture={gesture_command_match} cmds={gesture_command_match.sprint_commands()}")
                if (msg := gesture_command_match.msg) is not None:  # Print the associated message
                    debug(0, f"   Message: {msg}")

                # Run commands in a separate thread so as not to slow down event parsing loop
                timeout = gesture_command_match.timeout or CMD_TIMEOUT
                threading.Thread(target=run_bash_commands, args=(cmds, timeout,), daemon=True).start()
            else:  # No op
                debug(2, f">ACTION: gesture={gesture_command_match} cmds=NO-OP")
        else:
            debug(3, f"Notice: GestureCommand not present in GESTURE_CMDS_LIST: {gesture_str}")

        debug(2, "----------\n")
        return True

    def queue_closeout_sequence(self, gesture_data: GestureData, timeout: float) -> None:
        """ Queue closeout sequence to run in 'timeout' seconds"""

        last_group = self.last_group

        def timer_callback() -> None:
            if not self.is_registered() or last_group != ContactGroup.last_group_added(self.device_id):  # Sequence already completed (and unregistered) or new last group added
                return  # Abort
            debug(3, f"   Timeout={sec_to_ms(timeout,1)}ms time={truncate_time(self.end_time)} [{repr(self)}]")
            self.closeout_sequence(gesture_data)

        timer = threading.Timer(timeout, timer_callback)
        timer.daemon = False
        timer.start()

#-------------------------------------------------------------------------------
#### XInputEvent and XInputParser classes

@dataclass(slots=True)
class XInputEvent:
    "Collection of parameters that characterize an Xinput event"
    xevent: XEvent
    name: str | None = None
    device_id: int | None = None
    time: float | None = None
    detail: int | None = None
    position: tuple[int, int] | None = None # None for events without root coords

    @property
    def is_press(self) -> bool:
        """Returns true if event is a click/touch start  event"""
        return self.xevent in PRESS_EVENTS

    @property
    def is_release(self) -> bool:
        """Returns true if event is a click/touch release event"""
        return self.xevent in RELEASE_EVENTS

    @property
    def is_motion(self) -> bool:
        """Returns true if event is a motion event"""
        return self.xevent in MOTION_EVENTS

    @property
    def device_type(self) -> DeviceType:
        """Returns the DeviceType associated with the X event number"""
        if self.xevent in MOUSE_EVENTS:
            return DeviceType.MOUSE
        if self.xevent in TOUCH_EVENTS:
            return DeviceType.TOUCH
        return DeviceType.UNKNOWN

    def sprint(self) -> str:
        """Return human-readable event string"""
        return f"{self.device_type}[{self.get_detail_info()}] at t={truncate_time(self.time)} {self.position}"

    def get_detail_info(self) -> str:
        """
        - If Mouse, return: <button-name>(number)
        - If Touch, return: Finger(finger_num/tot_contact_fingers)
        """
        if self.device_type is DeviceType.MOUSE:
            button_name = MouseButton.safe_name(self.detail) # Name of button
            return f"{button_name}({self.detail})"
        if self.device_type is DeviceType.TOUCH:
            last_group = ContactGroup.last_group_added(self.device_id) if self.device_id is not None else None
            num_active_fingers = len(last_group.current_pressed) if last_group is not None else 0
            return f"{self.detail}:{num_active_fingers}"
        return f"{self.detail}"

class XInputEventFilled(XInputEvent):  # Note this is added to avoid type checking errors with mypy
    """A fully-populated XInputEvent — all fields guaranteed present."""
    device_id: int
    time: float
    detail: int
    position: tuple[int, int]


@dataclass
class XInputParser:
    """Class to parse event stanza input from 'xinput test-xi2 --root'"""

    _xtime_offset: float | None = None   # Difference between monotonic time and X-sever uptime

    def __init__(self) -> None:
        self.proc: subprocess.Popen[str] | None = None
        self._start_xinput()
        self.event: XInputEvent | None = None

    def _start_xinput(self) -> None:
        """Start xinput parsing"""
        self.proc = subprocess.Popen(  # pylint: disable=consider-using-with
            ['xinput', 'test-xi2', '--root'],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
        )
        debug(1, "Starting xinput test-xi2 --root...")

    def _restart_xinput(self) -> None:
        """Restart xinput if exits (note it can sometimes exit if monitor sleeps(?)))"""
        if self.proc:
            self.proc.terminate()
            self.proc.wait()  # Waits until the process has fully exited
        time.sleep(XINPUT_RESTART_DELAY)
        self._start_xinput()

    @classmethod
    def x_uptime(cls) -> float:
        """Return current X server uptime in seconds (float)."""
        return time.monotonic() - cls._xtime_offset if cls._xtime_offset is not None else 0

    _XLIB_DISPLAY: ClassVar[display.Display |  None ] = None
    _XLIB_ROOT: ClassVar[Window | None] = None
    @classmethod
    def get_pointer_position(cls) -> tuple[int, int]:
        """
        Return current root position (x,y) of (mouse) pointer or None if fails.
        First attempts to use pre-existing persistent display connection to query position if already connected.
        Otherwise or if initial query fails, attempt to (re)connect to display and request position again.
        """
        # Fast - leverage persistent connection
        if cls._XLIB_DISPLAY is not None and cls._XLIB_ROOT is not None:
            try:
                data = cls._XLIB_ROOT.query_pointer()  # Attempt to read existing connection
                return data.root_x, data.root_y
            except Exception:  # X server connection died or restarted
                if cls._XLIB_DISPLAY is not None:
                    try:
                        cls._XLIB_DISPLAY.close()
                    except Exception:
                        pass
                cls._XLIB_DISPLAY = None
                cls._XLIB_ROOT = None

        try: # (Re)create connection and attempt to read position
            cls._XLIB_DISPLAY  = display.Display()
            cls._XLIB_ROOT = cls._XLIB_DISPLAY.screen().root
            data = cls._XLIB_ROOT.query_pointer()
            debug(3, "(Re)connecting to X display to read pointer position")
            return data.root_x, data.root_y

        except Exception: # X server is down or permanently unreachable
            debug(0, "WARNING: Failed to connect to X display to read pointer position")
            if cls._XLIB_DISPLAY is not None:
                try:
                    cls._XLIB_DISPLAY.close()
                except Exception:
                    pass
            cls._XLIB_DISPLAY = None
            cls._XLIB_ROOT = None
            return (0,0)  # Fallback value

    raw_line_counter: ClassVar[int] = 0
    @staticmethod
    def print_raw(line: str) -> None:
        """Print numbered raw X event line."""
        XInputParser.raw_line_counter += 1
        print(f"[{XInputParser.raw_line_counter:04d}] RAW: {line}")

    def __iter__(self) -> Iterator[XInputEventFilled]:
        return self

    def __next__(self) -> XInputEventFilled:
        parse_event: bool = False
        click_event: bool  = False
        event_end: bool = False

        assert self.proc is not None and self.proc.stdout is not None
        while True:
            line = self.proc.stdout.readline()
            if not line:
                self._restart_xinput()
                continue
            line = line.strip()  # Remove newline
            if not line:
                continue

            if abs(LOG_LEVEL) >= 2 and (0x2380 <= ord(line[0]) <= 0x23BF):  # xinput preamble listing devices
                print(line)
                continue

            new_event = False
            event_separator = False
            if line.startswith("EVENT type"):  # Format is: EVENT type <event number> (<event_name>)
                new_event = True
                event_separator = True
                self.event = XInputEvent(
                    xevent = XEvent.get_event(int(line.split()[2])),  # Convert event number to XEvent
                    name   = line.split('(')[1].rstrip(')')
                )
                parse_event = self.event.xevent in PARSED_EVENTS
                click_event = self.event.xevent in CLICK_EVENTS

            # Raw debug printing
            if abs(LOG_LEVEL) >= 8 or (abs(LOG_LEVEL) == 7 and parse_event) or (abs(LOG_LEVEL) == 6 and click_event):
                if new_event:  # Skip line between events
                    print()
                    event_separator = False
                self.print_raw(line)
            if LOG_LEVEL < 0:
                continue

            if not parse_event or self.event is None:  # New event not yet started
                continue

            if self.event.xevent not in CLICK_EVENTS and self.event.device_id is not None and not ContactGroup.is_active(self.event.device_id):
                continue  # Don't record non-click events (e.g., motion) if not within a contact

            try:
                if new_event:  # Print out (debug) event line
                    debug(5, ("\n" if event_separator else "") + f"EVENT_NUM={self.event.xevent} ({self.event.name})") # Note can't put '\' inside an f-expression

                elif line.startswith("device:"):  # Format is device: <device_id> (<device_id> OR <attachment_id>))
                    self.event.device_id = int(line.split('(')[1].rstrip(')'))
                    debug(5, f"DEVICE={self.event.device_id}")

                elif line.startswith("time:"):  # Format is: time: <X-Server uptime in ms>
                    self.event.time = int(line.split(':')[-1].strip()) / 1000
                    debug(5, f"EVENT_TIME={self.event.time}")
                    type(self)._xtime_offset = time.monotonic() - self.event.time # Update offset

                elif line.startswith("detail:"):  # Format is: detail: <Button number for mouse or touch-finger for Touch>
                    self.event.detail = int(line.split('detail:')[-1].strip())
                    debug(5, f"DETAIL={self.event.detail}")

                elif line.startswith("root:"):  # Format is: root: <x_coord>/<y_coord>
                    parts = line.strip().split()
                    x_str, y_str = parts[1].split('/')
                    self.event.position = (int(float(x_str)), int(float(y_str)))
                    debug(5, f"POSITION={self.event.position}")
                    event_end  = True # No more lines need to be parsed for non-raw event

                elif line.startswith("valuators:"):  # End for Touch events
                    event_end = True  # No more lines need to be parsed for raw event

            except Exception as e:
                print(f"ERROR PARSING line: {line} -> {e}")

            if event_end:  # Continuing parsing current Event
                if self.event.position is None:  # Set position if unavailable
                    if self.event.device_type is DeviceType.MOUSE:  # For mouse, get root pointer position
                        self.event.position = type(self).get_pointer_position()
                    else:
                        self.event.position = (0, 0)
                return cast(XInputEventFilled, self.event)

#-------------------------------------------------------------------------------
#### Run commands
def run_bash_commands(cmds: CommandsType, timeout: int | None) -> None:
    """
    Run list of one or more shell commands safely (list[str | list[str]]) where each command is of form:
      - Single string (e.g., "ls -a -l")
      - Argv-style list (e.g., ["ls", "-l"])
    """
    if isinstance(cmds, str):
        cmds = [cmds] # Convert to list of single command string
    for cmd in cmds:
        try:
            if isinstance(cmd, str):  # Use shell if string-style command
                shell = True
            elif isinstance(cmd, list): # Argv-style command
                shell = False
                if not all(isinstance(arg, str) for arg in cmd):
                    raise ValueError(f"Invalid argv-style command syntax: {cmd}")
            else:
                raise ValueError(f"Invalid command syntax: {cmd}")

            result = subprocess.run(
                cmd,
                shell   = shell,
                check   = False,
                text    = True,
                stdout  = subprocess.PIPE,
                stderr  = subprocess.PIPE,
                timeout = timeout,              # Optional, defaults to CMD_TIMEOUT
            )
            if result.returncode != 0:
                debug(0, f"ERROR executing command (exit: {result.returncode}): {cmd}")
            else:
                debug(2, f":Execution success: {cmd}")

            if result.stdout:
                debug(2, "--- Stdout ---\n" + result.stdout)
            if result.stderr:
                debug(2, "--- Stderr ---\n" + result.stderr)

        except ValueError as e:
            debug(0, str(e))
        except subprocess.TimeoutExpired:
            debug(0, f"Command timed out: {cmd}")
        except subprocess.CalledProcessError as e:
            debug(0, f"Command failed (exit {e.returncode}): {cmd}")
        except Exception as e:
            debug(0, f"Failed to run command: {e} -> {cmd}")
        debug(3, "")

#-------------------------------------------------------------------------------
### Event processing functions

def process_PRESS(ev: XInputEventFilled) -> None:
    """ Add a new ButtonPress/TouchBegin event to relevant group"""
    debug(2, f"+PRESS {ev.sprint()}")
    with _registry_lock:
        between_presses_string = ""
        group = ContactGroup.last_group_added(ev.device_id)
        if not group or group.is_complete:  # Create and register new contact group if no incomplete group exists for ev.device_id
            group = ContactGroup(ev.device_id, ev.device_type, ev.detail, ev.time, ev.position)
            prev_group = ContactGroup.prev_group_added(ev.device_id)
            if prev_group is not None:  # Calculate time since previous new  press
                between_presses_string = f" [delta={sec_to_ms(group.start_time - prev_group.start_time)} ms]"
        else:  # Otherwise add to existing contact group
            if ev.device_type is DeviceType.TOUCH and ev.detail in group.current_pressed: # Avoid artifact repeat of same finger press
                #Note on touch a true re-tap of same finger would have a *different* detail
                return
            group.add_event(ev.detail, ev.time, ev.position, ContactState.PRESS)

        debug(4, group.sprint(between_presses_string))

def process_RELEASE(ev: XInputEventFilled) -> None:
    """Add a new ButtonReleae/TouchEnd event to relevant group and attempt to closeout gesture sequence if group is complete (no more contacts)"""
    debug(2, f"-RELEASE {ev.sprint()}")
    with _registry_lock:
        group = ContactGroup.last_group_added(ev.device_id)
        if group:  # Group should already exist since shouldn't have Release/TouchEnd before Press/TouchBegin
            if ev.detail not in group.current_pressed: # Can't release non-existing contact
                return
            group.add_event(ev.detail, ev.time, ev.position, ContactState.RELEASE)

            if group.is_complete: # All contacts (buttons/touches) released, so add completed group to gesture sequence for that ev.device_id
                gesture_data = group.classify_click() # Return gesture data: tuple(gesture, duration, distance, velocity)
                single_click_gesture = group.device_type.spec.is_single_click(gesture_data[0])

                seq = GestureSequence.get(ev.device_id)
                if seq:  # Gesture sequence already started
                    debug(4, group.sprint(f" [groups={len(seq.groups)}]"))
                    if single_click_gesture:  # Then existing sequence is closeable
                        gesture_data_prev = seq.last_group.classify_click()  # Gesture data for existing sequence
                        seq.closeout_sequence(gesture_data_prev) # Forcibly closeout existing sequence [as (N-1)-Click/Tap] before adding new group
                        seq = GestureSequence(group)  # Start new gesture with group
                    else:
                        seq.append(group)  # Add new group to existing sequence

                else:  # Start new sequence for new group
                    seq = GestureSequence(group)
                    debug(4, group.sprint(f" [groups={len(seq.groups)}]"))

                time_to_double_click_timeout = group.time_to_double_click_timeout
                if single_click_gesture or time_to_double_click_timeout < 0: # Possible to closeout sequence now
                    seq.closeout_sequence(gesture_data) # Possible to pass gesture data
                else:
                    seq.queue_closeout_sequence(gesture_data, time_to_double_click_timeout)

def process_MOTION(ev: XInputEventFilled) -> None:
    """ Add a new updated position event if detail is pressed in an active group"""
    debug(2, f"=MOTION {ev.sprint()}")
    with _registry_lock:
        group = ContactGroup.last_group_added(ev.device_id)
        if group and not group.is_complete and (ev.xevent in MOUSE_MOTION_EVENTS or ev.detail in group.current_pressed):
            # Only update if mouse motion or 'detail' is currently pressed in the group (i.e, between presses and releases)
            group.add_event(ev.detail, ev.time, ev.position, ContactState.MOTION)
            debug(4, group.sprint())

#-------------------------------------------------------------------------------
### Main event loop

def main() -> None:
    """Main Event Loop"""
    initialize()

    parser = XInputParser()
    for event in parser:
        # PRESS event
        if event.is_press:
            process_PRESS(event)

        # RELEASE event
        elif event.is_release:
            process_RELEASE(event)

        # MOTION/TouchUpdate Event
        elif event.is_motion:
        # Note: need to use RawMotion since no Motion updates when button clicked
            process_MOTION(event)

#-------------------------------------------------------------------------------
__all__ = [
    # Core enums
    "DeviceType",
    "GestureType",
    "MouseButton",
    "XEvent",
    "ContactState",

    # Core data classes
    "DeviceSpec",
    "ContactGroup",
    "GestureSequence",
    "GestureCommand",
    "XInputParser",

    # Key Type Aliases
    "CommandsType",
    "CommandsDict",
    "CommandsUnion",
    "EventRecord",
    "GestureData",

    # Public functions
    "initialize",
    "run_bash_commands",

    "__version__",
]

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nExiting cleanly.")
    except Exception:
        traceback.print_exc()
